"""
Module to parse and execute generated by Playwright codegen.
"""

import os
import sys
import time
import codecs
import warnings
from playwright.sync_api import sync_playwright, Page, Locator, FrameLocator, \
    TimeoutError as PlaywrightTimeoutError

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import helpers
from collectors import form_interactor

DEFAULT_VIEWPORT = {'width': 1280, 'height': 720}
MODULE_DIR = os.path.dirname(os.path.abspath(__file__)) + '/'
INTERACTION_FILE = "../recording_test.txt"

DEFAULT_VIEWPORT = {'width': 1280, 'height': 720}

HEADLESS = False

DEFAULT_CLICK_DELAY = 100
DEFAULT_INSTRUCTION_DELAY = 1000
DEFAULT_GOTO_DELAY = 3000
DEFAULT_VALUE = "unknown"
DEFAULT_BUTTON = "Tab"
DEFAULT_CLEAR_FIELDS = True

DEFAULT_TIMEOUT = 5000

def handle_goto(line : str):
    """
    Parse the codegen step for page.goto(url).
    Returns the reduced line and the dict with command: "goto" and value: url.
    """
    og_line = line
    instruction = {"command": "goto", "value": ""}
    line = line[len("goto(\""):]
    # fill should be the last command
    if line.endswith("\")"):
        instruction["value"] = line[:-2]
    else:
        # print(f"Error finding value for goto{og_line}")
        raise ValueError(f"Error finding url for goto in line: {og_line}")
    line = ""
    return line, instruction

def handle_click(line : str):
    """
    Parse the codegen step for locator.click(button=button, modifiers=[modifiers]).
    Returns the reduced line and the dict with command: "click" and value: 'button' 
    and modifiers:[modifiers].
    """
    # click(button="right", modifiers=["Alt", "Control"])
    instruction = {"command": "click", "value": "", "modifiers": []}
    line = line[len("click("):]
    value_line = line

    # Check for modifiers, and search for the end of the instruction.
    modifiers = line.find("modifiers=[")
    if modifiers != -1:
        # Take index minus three to remove possible "\", " characters from string.
        # If modifiers is only one present, button will still not be found.
        value_line = line[:modifiers-3]
        line = line[modifiers+len("modifiers="):]

        alt, control, control_or_meta, meta, shift = \
            line.find("Alt"), line.find("Control"), line.find("ControlOrMeta"), \
            line.find("Meta"), line.find("Shift")

        if alt != -1:
            instruction["modifiers"].append("Alt")
        if shift != -1:
            instruction["modifiers"].append("Shift")
        if control_or_meta != -1:
            instruction["modifiers"].append("ControlOrMeta")
        else:
            if control != -1:
                instruction["modifiers"].append("Control")
            if meta != -1:
                instruction["modifiers"].append("Meta")

    # Search for the button parameter
    # print(value_line)
    button_index = value_line.find("button=\"")
    if button_index != -1:
        instruction["value"] = value_line[len("button=\""):]

    line = ""
    return line, instruction

def handle_fill(line : str):
    """
    Parse the codegen step for locator.fill(input).
    Returns the reduced line and the dict with command: "fill" and value: input.
    """
    og_line = line
    instruction = {"command": "fill", "value": ""}
    line = line[len("fill(\""):]
    # fill should be the last command
    if line.endswith("\")"):
        instruction["value"] = line[:-2]
    else:
        warnings.warn(f"Error finding value {og_line}")
        instruction["value"] = DEFAULT_VALUE
    line = ""
    return line, instruction

def handle_press(line : str):
    """
    Parse the codegen step for locator.press("button").
    Returns the reduced line and the dict with command: "press" and value: button.
    """
    og_line = line
    instruction = {"command": "press", "value": ""}
    line = line[len("press(\""):]
    # press should be the last command
    if line.endswith("\")"):
        instruction["value"] = line[:-2]
    else:
        warnings.warn(f"Error finding button {og_line}")
        instruction["value"] = DEFAULT_BUTTON
    line = ""
    return line, instruction

def handle_get_by_alt_text(line : str, default_exact : bool):
    """
    Parse the codegen step for locator.get_by_alt_text(alt_text, exact=bool).
    Exact is an optional field, with default False.
    Returns the reduced line and the dict with 
    command: "get_by_alt_text", value: alt_text and exact: bool.
    """
    og_line = line
    instruction = {"command": "get_by_alt_text", "value": "", "exact": default_exact}
    line = line[len("get_by_alt_text(\""):]
    # Does not take into account double quotes
    exact = line.find(", exact=")
    if exact == -1:
        # No exact specified
        instruction["exact"] = default_exact
        end = line.find("\").")
        if end != -1:
            instruction["value"] = line[:end]
            line = line[end + len("\")."):]
        else:
            warnings.warn(f"Error finding value {og_line}, {line}")
            instruction["value"] = None
            line = ""
    else:
        instruction["exact"] = True
        instruction["value"] = line[:exact-1]
        line = line[exact+len(", exact="):]
        end = line.find(").")
        if end != -1:
            instruction["exact"] = line[:end] == "True"
            line = line[end + len(")."):]
        else:
            warnings.warn(f"Error finding exact {og_line}, {line}")
            line = ""

    return line, instruction


def handle_get_by_label(line : str, default_exact : bool):
    """
    Parse the codegen step for locator.get_by_label(label, exact=bool).
    Exact is an optional field, with default False.
    Returns the reduced line and the dict with 
    command: "get_by_label", value: label and exact: bool.
    """
    og_line = line
    instruction = {"command": "get_by_label", "value": "", "exact": default_exact}
    line = line[len("get_by_label(\""):]
    # Does not take into account double quotes
    exact = line.find(", exact=")
    if exact == -1:
        # No exact specified
        instruction["exact"] = default_exact
        end = line.find("\").")
        if end != -1:
            instruction["value"] = line[:end]
            line = line[end + len("\")."):]
        else:
            warnings.warn(f"Error finding value {og_line}, {line}")
            instruction["value"] = None
            line = ""
    else:
        instruction["exact"] = True
        instruction["value"] = line[:exact-1]
        line = line[exact+len(", exact="):]
        end = line.find(").")
        if end != -1:
            instruction["exact"] = line[:end] == "True"
            line = line[end + len(")."):]
        else:
            warnings.warn(f"Error finding exact {og_line}, {line}")
            line = ""

    return line, instruction

def handle_get_by_placeholder(line : str, default_exact : bool):
    """
    Parse the codegen step for locator.get_by_placeholder(placeholder, exact=bool).
    Exact is an optional field, with default False.
    Returns the reduced line and the dict with 
    command: "get_by_placeholder", value: placeholder and exact: bool.
    """
    og_line = line
    instruction = {"command": "get_by_placeholder", "value": "", "exact": default_exact}
    line = line[len("get_by_placeholder(\""):]
    # Does not take into account double quotes
    exact = line.find(", exact=")
    if exact == -1:
        # No exact specified
        instruction["exact"] = default_exact
        end = line.find("\").")
        if end != -1:
            instruction["value"] = line[:end]
            line = line[end + len("\")."):]
        else:
            warnings.warn(f"Error finding value {og_line}, {line}")
            instruction["value"] = None
            line = ""
    else:
        instruction["exact"] = True
        instruction["value"] = line[:exact-1]
        line = line[exact+len(", exact="):]
        end = line.find(").")
        if end != -1:
            instruction["exact"] = line[:end] == "True"
            line = line[end + len(")."):]
        else:
            warnings.warn(f"Error finding exact {og_line}, {line}")
            line = ""

    return line, instruction

def handle_get_by_role(line : str, default_exact : bool):
    """
    Parse the codegen step for locator.get_by_role(role, name=name).
    Returns the reduced line and the dict with 
    command: "get_by_role", value: role and name: name.
    """
    og_line = line
    instruction = {"command": "get_by_role", "value": "", "name": "", "exact": default_exact}
    line = line[len("get_by_role(\""):]

    value_line = line

    # Check if exact parameter is specified, and search for the end of the instruction.
    exact = line.find(", exact=")
    if exact == -1:
        # No exact specified
        instruction["exact"] = default_exact
        end = line.find("\").")
        if end != -1:
            value_line = line[:end]
            line = line[end + len("\")."):]
        else:
            warnings.warn(f"Error finding value and name {og_line}, {line}")
            instruction["name"] = None
            value_line = ""
            line = ""
    else:
        instruction["exact"] = True
        # Take index minus one to remove escaped " character from string
        value_line = line[:exact-1]
        line = line[exact+len(", exact="):]
        end = line.find(").")
        if end != -1:
            instruction["exact"] = line[:end] == "True"
            line = line[end + len(")."):]
        else:
            warnings.warn(f"Error finding exact {og_line}, {line}")
            line = ""

    # Search for the name parameter, and pass the remaining as value.
    name_index = value_line.find(", name=")
    if name_index != -1:
        # Take index minus one to remove escaped " character from string
        instruction["value"] = value_line[:name_index-1]
        # Take index plus one to remove escaped " character from string
        instruction["name"] = value_line[name_index+len(", name=")+1:]
    else:
        instruction["value"] = value_line
    return line, instruction

def handle_get_by_test_id(line : str):
    """
    Parse the codegen step for locator.get_by_test_id(test_id).
    Returns the reduced line and the dict with command: "get_by_test_id" and value: test_id.
    """
    og_line = line
    instruction = {"command": "get_by_test_id", "value": ""}
    line = line[len("get_by_test_id(\""):]

    end = line.find("\").")
    if end != -1:
        instruction["value"] = line[:end]
        line = line[end + len("\")."):]
    else:
        warnings.warn(f"Error finding value {og_line}")
        instruction["value"] = None
        line = ""
    return line, instruction

def handle_get_by_text(line : str, default_exact : bool):
    """
    Parse the codegen step for locator.get_by_text(text, exact=bool).
    Exact is an optional field, with default False.
    Returns the reduced line and the dict with command: "get_by_text", value: text and exact: bool.
    """
    og_line = line
    instruction = {"command": "get_by_text", "value": "", "exact": default_exact}
    line = line[len("get_by_text(\""):]
    # Does not take into account double quotes
    exact = line.find(", exact=")
    if exact == -1:
        # No exact specified
        instruction["exact"] = default_exact
        end = line.find("\").")
        if end != -1:
            instruction["value"] = line[:end]
            line = line[end + len("\")."):]
        else:
            warnings.warn(f"Error finding value {og_line}, {line}")
            instruction["value"] = None
            line = ""
    else:
        instruction["exact"] = True
        instruction["value"] = line[:exact-1]
        line = line[exact+len(", exact="):]
        end = line.find(").")
        if end != -1:
            instruction["exact"] = line[:end] == "True"
            line = line[end + len(")."):]
        else:
            warnings.warn(f"Error finding exact {og_line}, {line}")
            line = ""

    return line, instruction

def handle_get_by_title(line : str, default_exact : bool):
    """
    Parse the codegen step for locator.get_by_title(title, exact=bool).
    Exact is an optional field, with default False.
    Returns the reduced line and the dict with 
    command: "get_by_title", value: title and exact: bool.
    """
    og_line = line
    instruction = {"command": "get_by_title", "value": "", "exact": default_exact}
    line = line[len("get_by_title(\""):]
    # Does not take into account double quotes
    exact = line.find(", exact=")
    if exact == -1:
        # No exact specified
        instruction["exact"] = default_exact
        end = line.find("\").")
        if end != -1:
            instruction["value"] = line[:end]
            line = line[end + len("\")."):]
        else:
            warnings.warn(f"Error finding value {og_line}, {line}")
            instruction["value"] = None
            line = ""
    else:
        instruction["exact"] = True
        instruction["value"] = line[:exact-1]
        line = line[exact+len(", exact="):]
        end = line.find(").")
        if end != -1:
            instruction["exact"] = line[:end] == "True"
            line = line[end + len(")."):]
        else:
            warnings.warn(f"Error finding exact {og_line}, {line}")
            line = ""

    return line, instruction

def handle_frame_locator(line : str):
    """
    Parse the codegen step for locator.frame_locator(locator).
    Returns the reduced line and the dict with command: "frame_locator" and value: locator.
    """
    og_line = line
    instruction = {"command": "frame_locator", "value": ""}
    line = line[len("frame_locator(\""):]

    end = line.find("\").")
    if end != -1:
        instruction["value"] = line[:end]
        line = line[end + len("\")."):]
    else:
        warnings.warn(f"Error finding value {og_line}")
        instruction["value"] = None
        line = ""
    return line, instruction

def handle_locator(line : str):
    """
    Parse the codegen step for locator.locator(locator).
    Returns the reduced line and the dict with command: "locator" and value: locator.
    """
    og_line = line
    instruction = {"command": "locator", "value": ""}
    line = line[len("locator(\""):]

    end = line.find("\").")
    if end != -1:
        instruction["value"] = line[:end]
        line = line[end + len("\")."):]
    else:
        warnings.warn(f"Error finding value {og_line}")
        instruction["value"] = None
        line = ""
    return line, instruction

def handle_filter(line : str):
    """
    Parse the codegen step for locator.filter(has_text=text || has_not_text=not_text).
    Returns the reduced line and the dict with command: "filter",
    value:"text" or "not_text" and filter_type: text or not_text.
    """
    og_line = line
    instruction = {"command": "filter", "value": "", "filter_type": ""}
    line = line[len("filter("):]

    if line.startswith("has_text=\""):
        instruction["filter_type"] = "text"
        line = line[len("has_text=\""):]
    elif line.startswith("has_not_text=\""):
        instruction["filter_type"] = "not_text"
        line = line[len("has_not_text=\""):]
    elif line.startswith("has="):
        warnings.warn("Filter with the \"has\" field is currently unsupported." +
                      f"Instruction {og_line} will be skipped")
        return "", {"command": "", "value": ""}
    elif line.startswith("has_not="):
        warnings.warn("Filter with the \"has\" field is currently unsupported." +
                      f"Instruction {og_line} will be skipped")
        return "", {"command": "", "value": ""}

    end = line.find("\").")
    if end != -1:
        instruction["value"] = line[:end]
        line = line[end + len("\")."):]
    else:
        warnings.warn(f"Error finding value {og_line}, {line}")
        instruction = {"command": "", "value": ""}
        line = ""

    return line, instruction

def handle_nth(line : str):
    """
    Parse the codegen step for locator.nth(index).
    Returns the reduced line and the dict with command: "nth" and value: "index".
    """
    instruction = {"command": "nth", "value": ""}
    line = line[len("nth("):]

    end = line.find(").")
    instruction["value"] = line[:end]
    line = line[end + len(")."):]

    return line, instruction

def handle_first(line : str):
    """
    Parse the codegen step for locator.first.
    Returns the reduced line and the dict with command: "first" and value: "".
    """
    instruction = {"command": "first", "value": ""}
    line = line[len("first."):]
    return line, instruction

def handle_last(line : str):
    """
    Parse the codegen step for locator.first.
    Returns the reduced line and the dict with command: "last" and value: "".
    """
    instruction = {"command": "last", "value": ""}
    line = line[len("last."):]
    return line, instruction

def handle_check(line : str):
    """
    Parse the codegen step for locator.uncheck().
    Returns the reduced line and the dict with command: "uncheck" and value: "".
    """
    instruction = {"command": "check", "value": ""}
    line = ""
    return line, instruction

def handle_uncheck(line : str):
    """
    Parse the codegen step for locator.uncheck().
    Returns the reduced line and the dict with command: "uncheck" and value: "".
    """
    instruction = {"command": "uncheck", "value": ""}
    line = ""
    return line, instruction

def handle_set_checked(line : str):
    """
    Parse the codegen step for locator.set_checked(bool).
    Returns the reduced line and the dict with command: "set_checked" and value: bool.
    """
    instruction = {"command": "set_checked", "value": True}
    if line.endswith("False)"):
        instruction["value"] = False
    line = ""
    return line, instruction

def parse_codegen_instruction(line : str, default_exact : bool):
    """
    Parse a single step of the codegen file.
    Returns the reduced line and the identified instruction.
    If an instruction is unidentified, stop the parsing of that line.
    """
    instruction = {"command": "", "value": ""}

    if line.startswith("goto("):
        return handle_goto(line)
    if line.startswith("click("):
        return handle_click(line)
    if line.startswith("fill("):
        return handle_fill(line)
    if line.startswith("press("):
        return handle_press(line)
    if line.startswith("get_by_alt_text("):
        return handle_get_by_alt_text(line, default_exact)
    if line.startswith("get_by_label("):
        return handle_get_by_label(line, default_exact)
    if line.startswith("get_by_placeholder("):
        return handle_get_by_placeholder(line, default_exact)
    if line.startswith("get_by_role(\""):
        return handle_get_by_role(line, default_exact)
    if line.startswith("get_by_test_id(\""):
        return handle_get_by_test_id(line)
    if line.startswith("get_by_text(\""):
        return handle_get_by_text(line, default_exact)
    if line.startswith("get_by_title(\""):
        return handle_get_by_title(line, default_exact)
    if line.startswith("frame_locator(\""):
        return handle_frame_locator(line)
    if line.startswith("locator(\""):
        return handle_locator(line)
    if line.startswith("filter("):
        return handle_filter(line)
    if line.startswith("nth("):
        return handle_nth(line)
    if line.startswith("first."):
        return handle_first(line)
    if line.startswith("last."):
        return handle_last(line)
    if line.startswith("check("):
        return handle_check(line)
    if line.startswith("uncheck("):
        return handle_uncheck(line)
    if line.startswith("set_checked("):
        return handle_set_checked(line)

    warnings.warn(f"Instruction unknown: {line}")
    return "", instruction

def decode_input_value(value):
    """
    Removes double escaped characters and replaces them by the correct characters.
    (for exaple replace \\ \" by " and \\ \\ by \\ )
    """
    new_string = ""
    is_escaped = False

    for character in value:
        if is_escaped:
            is_escaped = False
            # new_string += character
            new_string += codecs.decode("\\"+character, 'unicode_escape')
            continue
        if character != "\\":
            new_string += character
            continue
        is_escaped = True
    return new_string

def check_optional(line : str):
    """
    Check if the given line ends with the # OPTIONAL comment.
    Returns the line without the comment and True if this is the case,
    otherwise it returns the original line and False.
    """
    index_hashtag = line.rfind("#")
    # print(index_hashtag, line[index_hashtag:])
    if line[index_hashtag:].replace(" ", "") == "#OPTIONAL":
        return line[:index_hashtag].strip(), True
    return line, False

def parse_codegen_line(line : str, default_exact : bool):
    """
    Parse a single line of instructions form the codegen file.
    Returns the list of steps identified.
    """
    instructions = []
    # Remove "page." from line
    line = line[len("page."):]
    line, optional = check_optional(line)

    if optional:
        instructions.append({"command": "OPTIONAL", "value": True})

    while line.strip() != "":
        # print(line)
        line, instruction = parse_codegen_instruction(line, default_exact)
        if instruction["command"] != "":
            # The file contains strings which are already escaped.
            # We need to remove this "double escaping",
            # without removing intended backslash characters
            # print(instruction["value"])
            if instruction["value"] is not None:
                # print("Pre decode: ", instruction["value"])
                instruction["value"] = decode_input_value(instruction["value"])
                # print("Post decode: ", instruction["value"])
            instructions.append(instruction)
        else:
            return []
    return instructions

def load_codegen_steps(filepath : str, default_exact : bool):
    """
    Take the given filepath and return the parsed instructions as a list
    with each item a line of the file represented as a list of steps to execute that instruction.
    Only takes into account instructions starting with "page.".
    """
    instruction_lines = []
    with open(filepath, 'r', encoding='utf8') as f:
        codegen_content = f.read().splitlines()

    for line in codegen_content:
        line = line.lstrip().rstrip()
        if line != "" and line.startswith("page."):
            # This is a line with an instruction we can use
            instructions = parse_codegen_line(line, default_exact)
            if len(instructions) != 0:
                instruction_lines.append(instructions)

    return instruction_lines







# # # # # # # # # # # # # # # # #
# Start of the execution code.  #
# # # # # # # # # # # # # # # # #

def execute_click(page_or_locator : Locator, step : dict, click_delay):
    """
    Execute the click command with the correct modifiers.
    """
    try:
        page_or_locator.scroll_into_view_if_needed(timeout = 2000)
    except PlaywrightTimeoutError:
        pass
    if step["value"] != "":
        if len(step["modifiers"]) != 0:
            page_or_locator.click(button=step["value"], modifiers=step["modifiers"],\
                                   delay=click_delay, timeout=DEFAULT_TIMEOUT)
        else:
            page_or_locator.click(button=step["value"], delay=click_delay, timeout=DEFAULT_TIMEOUT)
    else:
        if len(step["modifiers"]) != 0:
            page_or_locator.click(modifiers=step["modifiers"], delay=click_delay, \
                                  timeout=DEFAULT_TIMEOUT)
        else:
            page_or_locator.click(delay=click_delay, timeout=DEFAULT_TIMEOUT)

def common_starting_substring(current_value, value_to_fill):
    """
    Determine the common starting substring of both values, 
    and if that string is shorter than the current value.
    """
    min_len = min(len(current_value), len(value_to_fill))
    common_lenght = 0
    smaller = False

    for i in range(min_len):
        if current_value[i] == value_to_fill[i]:
            common_lenght += 1
        else:
            break

    common_substring = current_value[:common_lenght]
    if common_lenght < len(current_value):
        smaller = True
    return common_lenght, common_substring, smaller

def execute_fill(page : Page, page_or_locator : Locator, step : dict, clear_fields : bool, log = print):
    """
    Execute the fill step. Takes into account if we are adding to existing value of the field.
    """
    try:
        page_or_locator.scroll_into_view_if_needed(timeout = 2000)
    except PlaywrightTimeoutError:
        pass
    value_to_fill = step["value"]
    if clear_fields:
        current_value = page_or_locator.input_value(timeout=DEFAULT_TIMEOUT)
        common_lenght, common_substring, smaller = \
            common_starting_substring(current_value, step["value"])
        if smaller:
            page_or_locator.fill(common_substring)
        value_to_fill = step["value"][common_lenght:]

    form_interactor.type_sequentially(page_or_locator, value_to_fill, page)
    log("Fill successfull")

def execute_step(page : Page, page_or_locator : Locator, step : dict, log, options : dict = None):
    """
    Execute a given identified step by calling the correct function on the given locator.
    """
    click_delay = options.get("click_delay") if (options and options.get("click_delay")) \
        else DEFAULT_CLICK_DELAY
    clear_fields = options.get("clear_fields") if (options and options.get("clear_fields")) \
        else DEFAULT_CLEAR_FIELDS

    timed_out = False

    match step["command"]:
        case "goto":
            url = step["value"]
            try:
                page_or_locator.goto(url)
                helpers.block_closed_shadows(page)
                # page.mouse.move(200, 200)
                page.wait_for_timeout(DEFAULT_GOTO_DELAY)
            except Exception as e:
                raise Exception(f"Error while navigating to {url} \n") from e
            return None, timed_out
        case "click":
            execute_click(page_or_locator, step, click_delay)
            return None, timed_out
        case "fill":
            execute_fill(page, page_or_locator, step, clear_fields, log)
            return None, timed_out
        case "press":
            page_or_locator.press(step["value"], timeout=DEFAULT_TIMEOUT)
            return None, timed_out
        case "get_by_alt_text":
            return page_or_locator.get_by_alt_text(step["value"], exact=step["exact"]), timed_out
        case "get_by_label":
            return page_or_locator.get_by_label(step["value"], exact=step["exact"]), timed_out
        case "get_by_placeholder":
            return page_or_locator.get_by_placeholder(step["value"], exact=step["exact"]), timed_out
        case "get_by_role":
            return page_or_locator.get_by_role(step["value"], name=step["name"], \
                                               exact=step["exact"]), timed_out
        case "get_by_test_id":
            return page_or_locator.get_by_test_id(step["value"]), timed_out
        case "get_by_text":
            return page_or_locator.get_by_text(step["value"], exact=step["exact"]), timed_out
        case "get_by_title":
            return page_or_locator.get_by_title(step["value"], exact=step["exact"]), timed_out
        case "frame_locator":
            return page_or_locator.frame_locator(step["value"]), timed_out
        case "locator":
            return page_or_locator.locator(step["value"]), timed_out
        case "filter":
            if step["filter_type"] == "text":
                return page_or_locator.filter(has_text=step["value"]), timed_out
            elif step["filter_type"] != "not_text":
                return page_or_locator.filter(has_not_text=step["value"]), timed_out
            else:
                warnings.warn(\
                    f"Problem for executing filter, no correct values: {step}")
                log(f"⚠️ Problem for executing filter, no correct values: {step}")
        case "nth":
            return page_or_locator.nth(int(step["value"])), timed_out
        case "first":
            return page_or_locator.first, timed_out
        case "last":
            return page_or_locator.last, timed_out
        case "check":
            try:
                page_or_locator.scroll_into_view_if_needed(timeout = 2000)
            except PlaywrightTimeoutError:
                pass
            try:
                page_or_locator.check(timeout=DEFAULT_TIMEOUT)
            except PlaywrightTimeoutError:
                timed_out = True
                # warnings.warn(\
                #     f"Timeout for executing step, layout may have changed: {step}")
            except Exception:
                try:
                    # Attempt to click a second time
                    page_or_locator.check(timeout=DEFAULT_TIMEOUT)
                except Exception:
                    warnings.warn(\
                        f"Clicking the checkbox did not change its state: {step}")
                    log(f"⚠️ Clicking the checkbox did not change its state: {step}")
            return None, timed_out
        case "uncheck":
            try:
                page_or_locator.scroll_into_view_if_needed(timeout = 2000)
            except PlaywrightTimeoutError:
                pass
            try:
                page_or_locator.uncheck(timeout=DEFAULT_TIMEOUT)
            except PlaywrightTimeoutError:
                timed_out = True
                # warnings.warn(\
                #     f"Timeout for executing step, layout may have changed: {step}")
            except Exception:
                try:
                    # Attempt to click a second time
                    page_or_locator.uncheck(timeout=DEFAULT_TIMEOUT)
                except Exception:
                    warnings.warn(\
                        f"Clicking the checkbox did not change its state: {step}")
                    log(f"⚠️ Clicking the checkbox did not change its state: {step}")
            return None, timed_out
        case "set_checked":
            try:
                page_or_locator.scroll_into_view_if_needed(timeout = 2000)
            except PlaywrightTimeoutError:
                pass
            try:
                page_or_locator.set_checked(step["value"], timeout=DEFAULT_TIMEOUT)
            except PlaywrightTimeoutError:
                timed_out = True
                # warnings.warn(\
                #     f"Timeout for executing step, layout may have changed: {step}")
            except Exception:
                try:
                    # Attempt to click a second time
                    page_or_locator.set_checked(step["value"], timeout=DEFAULT_TIMEOUT)
                except Exception:
                    warnings.warn(\
                        f"Clicking the checkbox did not change its state: {step}")
                    log(f"⚠️ Clicking the checkbox did not change its state: {step}")
            return None, timed_out
        case _:
            warnings.warn(f"Unknown step: {step['command']}")
            log(f"⚠️ Unknown step: {step['command']}")
            return None, timed_out

def execute_frame_locator(page : Page, locator : Locator, instruction : list[dict], frame_substitute : dict, log = print, options : dict = None):
    """
    If required, try to find a different frame that fullfills the instruction.
    """
    filled_value = None
    url = ""
    final_url = ""
    locator = page
    timed_out = False
    index = 0
    frame_value = ""


    # Loop through steps in case frame locator is not first instruction
    for i, step in enumerate(instruction):
        if step["command"] == "frame_locator":
            index = i
            frame_value = step["value"]
            break
        try:
            locator, step_timed_out = execute_step(page, locator, step, log, options)
            if step_timed_out:
                timed_out = True
        except PlaywrightTimeoutError:
            timed_out = True
    if timed_out:
        return filled_value, url, final_url, timed_out, frame_substitute

    # Try to find a substitute frame from previous
    if frame_value in frame_substitute:
        # print(f"Using substitute frame: {instruction}")
        log("Using substitute frame")
        filled_value, url, final_url, timed_out, frame_substitute = \
            execute_instruction(page, instruction[index+1:], frame_substitute, \
                                log, options, frame_substitute[frame_value])

        # If substitution is found, continue normally with instruction
        if not timed_out:
            log("Substitution used successfully")
            return filled_value, url, final_url, timed_out, frame_substitute

    # Check if frame is located
    try:
        # Try to complete the instruction
        filled_value, url, final_url, timed_out, frame_substitute = \
            execute_instruction(page, instruction[index+1:], frame_substitute, \
                                log, options, locator.frame_locator(frame_value))
    except PlaywrightTimeoutError:
        timed_out = True

    # If frame is found, continue normally with instruction
    if not timed_out:
        # print(f"Frame found: {instruction}")
        log("Frame found")
        return filled_value, url, final_url, timed_out, frame_substitute
    log("Frame not found")

    # Check if any more commands are frame locators
    for i, step in enumerate(instruction[index+1:]):
        if step["command"] == "frame_locator":
            index = index+1 + i
            frame_value = step["value"]

    # Find new substitute
    # print(f"Will try to find substitute frame: {instruction}")
    log("Will try to find substitute frame")
    log(instruction)
    # form_interactor.scroll_to_bottom(page)
    frames = helpers.dump_frame_tree(page.main_frame)
    log(f"Frames: {len(frames)}")
    for frame in frames:
        timed_out = False
        if frame.url == "":
            continue
        try:
            # Try to complete the instruction
            filled_value, url, final_url, timed_out, frame_substitute = \
                execute_instruction(page, instruction[index+1:], frame_substitute, log, options, frame)
        except PlaywrightTimeoutError:
            timed_out = True
        except Exception as e:
            # print("Exeption: ", e)
            timed_out = True
        if not timed_out:
            frame_substitute[frame_value] = frame
            # print(f"Found substitute frame: {instruction}")
            log("Found substitute frame")
            return filled_value, url, final_url, timed_out, frame_substitute

    if timed_out:
        warnings.warn(f"Could not find a substitute frame for instruction: {instruction}")
        log(f"⚠️ Could not find a substitute frame for instruction: {instruction}")
    return filled_value, url, final_url, timed_out, frame_substitute

def execute_instruction(page : Page, instruction : list[dict], frame_substitute : dict, log = print, options : dict = None, frame : FrameLocator = None):
    """
    Execute a single instruction, represented as list of steps.
    Returns a string if a fill command was executed, or None otherwise.
    """
    filled_value = None
    url = ""
    final_url = ""
    locator = page
    if frame is not None:
        locator = frame
    timed_out = False

    if options["substitute_frames"]:
        for step in instruction:
            if step["command"] == "frame_locator":
                return execute_frame_locator(page, locator, instruction, frame_substitute, log, options)

    for step in instruction:
        old_locator = locator
        try:
            start_time = time.time()
            locator, step_timed_out = execute_step(page, locator, step, log, options)
            if step_timed_out:
                timed_out = True
            if locator is None:
                if step["command"] == "fill":
                    filled_value  = {"value": step["value"], "start_time": start_time}
                    try:
                        filled_value = {"id": old_locator.get_attribute("id"),
                                        "value": step["value"],
                                        "type": old_locator.get_attribute("type"),
                                        "start_time": start_time}
                    except PlaywrightTimeoutError:
                        log("Timeout getting attributes of filled values.")
                if step["command"] == "goto":
                    url = step["value"]
                    final_url = page.url
                break
        except PlaywrightTimeoutError:
            # warnings.warn(\
            #     f"Timeout for executing step in instruction, layout may have changed: {step} in {instruction}")
            timed_out = True
    return filled_value, url, final_url, timed_out, frame_substitute

def execute_codegen_instructions(page : Page, instructions : list[list[dict]], \
                                 log = print, options : dict = None):
    """
    Execute the identified instructions on the given page.
    Returns a list of values that were filled during this execution.
    """
    log("\nStarting codegen execution.")
    start_time = time.time()
    filled_values = []
    timestamps = []
    url = ""
    final_url = ""
    instruction_delay = DEFAULT_INSTRUCTION_DELAY
    if options and options.get("instruction_delay"):
        if isinstance(options.get("instruction_delay"), int) and \
                options.get("instruction_delay") > 0:
            instruction_delay = options.get("instruction_delay")

    timed_out_instructions = []
    frame_substitute = dict()

    exit_due_to_timeout = False

    for instruction in instructions:
        if exit_due_to_timeout:
            break
        timestamp = time.time()
        log("")
        log(timestamp)
        log(instruction)
        logline = f"⚠️ Timeout for executing instruction, layout may have changed: {instruction}"
        timestamps.append(timestamp)
        optional = False
        try:
            if instruction[0] == {"command": "OPTIONAL", "value": True}:
                log("OPTIONAL instruction found.")
                instruction = instruction[1:]
                optional = True
            filled_value, new_url, new_final_url, timed_out, frame_substitute = \
                execute_instruction(page, instruction, frame_substitute, log, options)
            if filled_value:
                filled_values.append(filled_value)
            if url == "" and new_url != "":
                url = new_url
                final_url = new_final_url
            if timed_out:
                if optional:
                    logline = "OPTIONAL instruction timed out, will continue: " +\
                                f"{instruction}"
                    log(logline)
                    continue

                warnings.warn(logline)
                log(logline)
                timed_out_instructions.append(instruction)
                if options["substitute_frames"]:
                    for step in instruction:
                        if step["command"] == "frame_locator":
                            logline = "⚠️ Will quit execution due to failed frame substitution: " +\
                                f"{instruction}"
                            warnings.warn(logline)
                            log(logline)
                            exit_due_to_timeout = True
                            break
        except PlaywrightTimeoutError:
            warnings.warn(logline)
            log(logline)
            timed_out_instructions.append(instruction)
        page.wait_for_timeout(instruction_delay)
    # log(filled_values)
    end_time = time.time()
    log(f"📃 Executing codegen took {end_time-start_time:0.1f} s")
    return filled_values, url, final_url, timed_out_instructions, timestamps
